---
title: Строки
---

# `str`

В нашем курсе мы постоянно работаем с типом `str` — строками.
На этой странице представлен обзор всего того, что мы уже знаем о них.


### Создание строк

#### Одинарные и двойные кавычки
«Базовый» способ создание объектов типа `str` — это запись набора юникодных символов между парой кавычек. Можно использовать как одинарные кавычки, так и двойные, главное одни и те же. Внутри одного типа кавычек можно использовать кавычки другого типа.

```python
>>> s = 'Я ♥︎ питон'
>>> s = "ООО 'Рога и копыта'"
```

#### Тройные кавычки
Вместо пары кавычек может использоваться пара трёх подряд идущих двойных кавычек `"""` (иногда вместо них используются тройные одинарные кавычки `'''`).
Основное преимущество тройных кавычек состоит в том, что между ними может использоваться перенос строки.

```python
>>> s = """Вчера начнется в три утра.
... В горах откроется нора.
... Найдет приют малютка Соня
... В Преображенском гарнизоне.
... А не захочет — не найдет,
... Лишь серый волк ее поймет.
...
... Джордж Гуницкий
"""
```

Внутри тройных кавычек можно без экранирования использовать обычные кавычки (конечно, если последний символ в строке не совпадает с `"`).

```python
>>> s = """Оксана сказала: 'Вчера с Семёном ходили на "Человека с киноаппаратом"'"""
>>> print(s)
Оксана сказала: 'Вчера с Семёном ходили на "Человека с киноаппаратом"'
```

#### `str()`
Функция `str()` превращает в строки другие питоновские объекты.
Не стоит злоупотреблять этим преобразованием, например сложно придумать разумное использование преобразования списка в строку, если вы не собираетесь получившуюся строку печатать.

```python
>>> x = 5
>>> x
5
>>> s = str(x)
>>> s
'5'
>>> x != s
True
```

#### Экранирование

Если в строке встречается специальный символ `\` (бэкслеш, обратная косая черта), то идущий за ним символ может интерпретироваться особым образом.
Такое влияние бэкслеша называется экранированием.
Например, сочетание `\n` обозначает перевод на строку, то есть обозначает конец текущей и начало новой строки.
Ещё часто используется `\t` (символ табуляции), а сам символ бэкслеш обозначается как `\\`.
Кроме того, можно экранировать кавычку, чтобы использовать её как символ строки, а не как обозначение её начала или конца.

```python
>>> s = 'Apples\t10\nOranges\t7\nCoconuts\t23'
>>> print(s)
Apples	10
Oranges	7
Coconuts	23

>>> s = 'Mama Smith\'s \\Pancake\\'
>>> print(s)
Mama Smith's \Pancake\
```

#### «Сырые» строки
Питону можно указать, что вы не желаете использовать экранирование.
Это можно сделать с помощью префикса `r` (от raw, реже используют `R`) перед первой кавычкой.
Этот способ работает со всеми видами кавычек и бесценен при использовании регулярных выражений.

```python
>>> s = r'Apples\t10\nOranges\t7\nCoconuts\t23'
>>> print(s)
Apples\t10\nOranges\t7\nCoconuts\t23

>>> s = r'Mama Smith\'s \\Pancake\\'
>>> print(s)
Mama Smith\'s \\Pancake\\
```


### Проверка наличия подстроки

#### Оператор `in`

`in` позволяет узнать является ли одна строка частью другой.

```python
>>> long = 'Hello, dear Mary'
>>> short = 'dear'
>>> if short in long:
...     print(short, 'is a part of', long)
...
dear is a part of Hello, dear Mary
>>> short in long
True
>>> long in short
False
```

#### Проверка наличия подстрок в начале или в конце строки: `str.startswith(substr)`, `str.endswith(substr)`

Методы проверяют наличие определенной последовательности символов в начале (startswith) или в конце (endswith) строки. То есть, как следует из их название, начинается ли и заканчивается ли строка на определенную последовательность (последовательность может быть и из одного символа), и возвращают `True` или `False`.

```python
>>> 'абв'.startswith('аб')
True
>>> 'абв'.endswith('б')
False
```

#### Поиск положения: `str.find()`, `str.rfind()`
—


### Регистр

#### Проверка регистра: `str.islower()`, `str.isupper()`, `str.istitle()`

Эти методы возвращают `True` или `False` в зависимости от того, как написаны буквы в строке: строчными или заглавными.
`.islower()` сообщает, что все буквы в строке строчные, `.isupper()` — заглавные, `.istitle()` сообщает, что первая встретившаяся буква в каждом «слове» — заглавная, а остальные — строчные.

```python
>>> strings = ['h', 'H', 'hello', 'Hello', 'hello world', 'HELLO WORLD',
...            'Hello world', 'Hello World']
>>> for s in strings:
...     print(s, end=': ')
...     if s.islower():
...         print('lower', end=', ')
...     if s.isupper():
...         print('upper', end=', ')
...     if s.istitle():
...         print('title', end=', ')
...     print()
h: lower,
H: upper, title,
hello: lower,
Hello: title,
hello world: lower,
HELLO WORLD: upper,
Hello world:
Hello World: title,

```

Все эти методы для строки без букв (в том числе для пустой) возвращают `False`:

```python
>>> ''.islower() or ''.isupper() or ''.ititle()
False
>>> '123'.islower() or '123'.isupper() or '123'.istitle()
False
```

#### Приведение к другому регистру: `str.lower()`, `str.upper()`, `str.capitalize()`, `str.title()`

`str.lower()` приводит все символы в строке к нижнему регистру. Удобно для унификации текста, для подсчетов слов, независимо от того, как они написаны.

```python
>>> s = 'АО МММ. У МММ нет проблем'
>>> s.lower()
'ао ммм. у ммм нет проблем'
```

`str.upper()` работает наоборот: превращает все символы в строке в символы верхнего регистра.

`str.capitalize()` поднимает регистр у первого символа в строке

```python
>>> s = 'вышка'
>>> s.capitalize()
'Вышка'
>>> s = 'университет — вышка'
>>> s.capitalize()
'Университет — вышка'
```

`str.title()` поднимает регистр у каждого «слова»

```python
>>> s = 'университет вышка'
>>> s.title()
'Университет Вышка'
```


### Разбиение и объединение

#### Разбиение: `str.split()`
—

#### Операторы `+` и `+=`

Строки можно конкатенировать (объединять) с помощью операторов `+` и `+=`:

```python
>>> s1 = 'abc'
>>> s2 = 'XYZ'
>>> s1 + s2
'abcXYZ'
>>> s2 += s1
>>> s2
'XYZabc'
```

#### Объединение: `str.join()`

Если нужно конкатенировать (объединить) сразу много строк, которые являются элементами списка (или другой коллекции), то удобный и быстрый способ — это `.join()`. Строка, к которой применяется метод, используется как разделитель, а список строк, передаваемые как аргумент — как части новой строки.

```python
>>> strings = ['milk', 'eggs', 'honey', 'flour']
>>> ''.join(strings)
'milkeggshoneyflour'
>>> ', '.join(strings)
'milk, eggs, honey, flour'
>>> print('\n'.join(strings))
milk
eggs
honey
flour

```

Обратите внимание, что `.join()` — это обратный метод по отношению к `.split()`, вызванному с каким-то аргументом:

```python
>>> long_string = 'milk, eggs, honey, flour'
>>> delimiter = ', '
>>> strings = long_string.split(delimiter)
>>> long_string == delimiter.join(strings)
True
```

### Модификация

#### Замена: `str.replace()`
—

#### Обрезание хвостов: `str.strip()`
Метод `.strip()` удаляет «лишние» символы в начале и конце строки. По умолчанию, без аргументов, удаляются все пробельные символы (пробелы, переносы строк и т.п.) от начала и до первого непробельного символа, а также от последнего непробельного символа до конца строки.

```python
>>> s = '\t   \t hello world\n\n   \n'
>>> print(s)
	   	 hello



>>> s.strip()
'hello world'
```

Если в качестве аргумента передать строку, то вместо пробельных символов удаляться символы, указанные в переданной строке.

```python
>>> s = '.--;....;.;-.;-...-;..;-...-;.--;help.-;...;-...-;-.--;---;..-;-.;--.;.;.-.;'
>>> s.strip('-.;')
'help'
```

